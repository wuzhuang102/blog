(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{262:function(_,a,t){"use strict";t.r(a);var v=t(28),r=Object(v.a)({},(function(){var _=this,a=_.$createElement,t=_._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"算法思维训练"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法思维训练"}},[_._v("#")]),_._v(" 算法思维训练")]),_._v(" "),t("h2",{attrs:{id:"_1-算法思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-算法思路"}},[_._v("#")]),_._v(" 1. 算法思路")]),_._v(" "),t("h3",{attrs:{id:"_1-1-计算机原理法（位运算）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-计算机原理法（位运算）"}},[_._v("#")]),_._v(" 1.1 计算机原理法（位运算）")]),_._v(" "),t("p",[t("a",{attrs:{href:"/wiki/base/bit-operation"}},[_._v("位运算")])]),_._v(" "),t("h3",{attrs:{id:"_1-2-双指针技巧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-双指针技巧"}},[_._v("#")]),_._v(" 1.2 双指针技巧")]),_._v(" "),t("p",[_._v("双指针技巧可以分为两类，"),t("strong",[_._v("快慢指针")]),_._v("：主要解决链表问题；"),t("strong",[_._v("左右指针")]),_._v("：解决数组或者字符串中的问题。")]),_._v(" "),t("h4",{attrs:{id:"快慢指针算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快慢指针算法"}},[_._v("#")]),_._v(" 快慢指针算法")]),_._v(" "),t("h5",{attrs:{id:"_1-判断链表是否有环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-判断链表是否有环"}},[_._v("#")]),_._v(" 1. 判断链表是否有环")]),_._v(" "),t("h5",{attrs:{id:"_2-已知链表有环，返回这个环的位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-已知链表有环，返回这个环的位置"}},[_._v("#")]),_._v(" 2. 已知链表有环，返回这个环的位置")]),_._v(" "),t("h5",{attrs:{id:"_3-寻找链表的中点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-寻找链表的中点"}},[_._v("#")]),_._v(" 3. 寻找链表的中点")]),_._v(" "),t("h5",{attrs:{id:"_4-寻找链表的倒数第-k-个元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-寻找链表的倒数第-k-个元素"}},[_._v("#")]),_._v(" 4. 寻找链表的倒数第 K 个元素")]),_._v(" "),t("h4",{attrs:{id:"左右指针算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#左右指针算法"}},[_._v("#")]),_._v(" 左右指针算法")]),_._v(" "),t("h5",{attrs:{id:"_1-二分查找"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-二分查找"}},[_._v("#")]),_._v(" 1. 二分查找")]),_._v(" "),t("h5",{attrs:{id:"_2-两树只和"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-两树只和"}},[_._v("#")]),_._v(" 2. 两树只和")]),_._v(" "),t("h5",{attrs:{id:"_3-反转数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-反转数组"}},[_._v("#")]),_._v(" 3. 反转数组")]),_._v(" "),t("h5",{attrs:{id:"_4-滑动窗口算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-滑动窗口算法"}},[_._v("#")]),_._v(" 4. 滑动窗口算法")]),_._v(" "),t("h3",{attrs:{id:"_1-3-递归思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-递归思想"}},[_._v("#")]),_._v(" 1.3 递归思想")]),_._v(" "),t("h3",{attrs:{id:"_1-4-广度优先与深度优先（树结构）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-广度优先与深度优先（树结构）"}},[_._v("#")]),_._v(" 1.4 广度优先与深度优先（树结构）")]),_._v(" "),t("h2",{attrs:{id:"_2-常用思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-常用思路"}},[_._v("#")]),_._v(" 2. 常用思路")]),_._v(" "),t("h3",{attrs:{id:"_2-1-暴力破解法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-暴力破解法"}},[_._v("#")]),_._v(" 2.1 暴力破解法")]),_._v(" "),t("p",[_._v("根据问题声明的定义，找到所有可变化的因子，穷举所有可能解决问题的方法")]),_._v(" "),t("p",[_._v("暴力破解法应用于数据查找，由于查找比较次数与给定目标的规模直接相关，所以也称为线性查找")]),_._v(" "),t("ul",[t("li",[_._v("选择排序")]),_._v(" "),t("li",[_._v("冒泡排序")]),_._v(" "),t("li",[_._v("顺序查找")]),_._v(" "),t("li",[_._v("暴力字符串匹配")])]),_._v(" "),t("h3",{attrs:{id:"_2-2-分治法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-分治法"}},[_._v("#")]),_._v(" 2.2 分治法")]),_._v(" "),t("p",[_._v("分治法，即“分而治之”，是将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归的解决这些问题，然后再合并结果，以得到原问题的解。")]),_._v(" "),t("p",[_._v("分治问题的三个步骤")]),_._v(" "),t("ol",[t("li",[_._v("分治（Divide）：将原问题分解成一系列与原问题同质的子问题")]),_._v(" "),t("li",[_._v("解决（Conquer）：递归的解决隔壁子问题，若问题足够小，则直接求解")]),_._v(" "),t("li",[_._v("合并（Combine）：将问题的结果合并成原问题的解")])]),_._v(" "),t("p",[_._v("分治法所能解决问题具有的一般特征")]),_._v(" "),t("ol",[t("li",[_._v("可以将问题分解为若干规模较小的相同问题")]),_._v(" "),t("li",[_._v("问题的规模缩小到一定程度以后就可以很容易地解决")]),_._v(" "),t("li",[_._v("问题分解出的子问题的解可以合并为该问题的解")]),_._v(" "),t("li",[_._v("问题所分解出的各个子问题是相互独立的，即子问题之间不再包含公共的孙问题")])]),_._v(" "),t("p",[_._v("分治法的典型应用")]),_._v(" "),t("ol",[t("li",[_._v("归并排序（Merge Sort）")]),_._v(" "),t("li",[_._v("快速排序（Quick Sort）")]),_._v(" "),t("li",[_._v("二分查找（Binary Search）")])]),_._v(" "),t("h3",{attrs:{id:"_2-3-回溯法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-回溯法"}},[_._v("#")]),_._v(" 2.3 回溯法")]),_._v(" "),t("p",[_._v("回溯法描述了一种选优搜索过程，按选优条件向前搜索，以达到目标。但当探索到某一步时，大仙原先的选择并不优或达不到目标，就退回一步重新选择。")]),_._v(" "),t("p",[_._v("回溯法可以理解为隐式的深度优先搜索算法。其在包含问题的所有解的解空间树中，按照深度优先搜索 的策略，从根节点出发深度探索解空间树。当探索到某一节点时，要先判断该节点是否包含问题的解， 如果包含，就从该节点出发继续探索下去，如果该节点不包含问题的解，则逐层向其祖先节点回溯。")]),_._v(" "),t("p",[_._v("一般步骤")]),_._v(" "),t("ol",[t("li",[_._v("针对给定的问题，确定问题的解空间，问题的解空间至少应该包含问题的一个（最优）解")]),_._v(" "),t("li",[_._v("确定节点的扩展搜索规则")]),_._v(" "),t("li",[_._v("以深度优先方式搜索解空间，并在搜索过程中用减枝函数避免无效搜索")])]),_._v(" "),t("h3",{attrs:{id:"_2-4-动态规划"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-动态规划"}},[_._v("#")]),_._v(" 2.4 动态规划")]),_._v(" "),t("p",[_._v("动态规划的过程可以描述为多阶段最优化解决问题的过程，每一次的决策依赖于当前的状态，随即又引起状态的转移，以此类推在变化的状态中产生出决策序列。")]),_._v(" "),t("p",[_._v("动态规划首先将待求解的问题分解为若干个子问题(阶段)，按顺序求解子问题。前一子问题的解为后 一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些 有可能达到最优的局部解，丢弃其他局部解。以此类推解决各子问题，最后一个子问题的解就是初始问 题的解。")]),_._v(" "),t("p",[t("strong",[_._v("动态规划与分治法最大的差别")]),_._v("是:适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互 相独立的(即下一个子问题的求解是建立在上一个子问题的解的基础上，进行进一步的求解)。")]),_._v(" "),t("p",[_._v("动态规划所能解决的问题一般具有以下几个特征")]),_._v(" "),t("ol",[t("li",[_._v("最优化原理")]),_._v(" "),t("li",[_._v("无后效行")]),_._v(" "),t("li",[_._v("有重叠子问题")])]),_._v(" "),t("p",[_._v("动态规划基本步骤")]),_._v(" "),t("ol",[t("li",[_._v("划分阶段:按照问题的时间或空间特征，把问题分为若干个阶段。注意划分后的阶段一定要是有序 的或者是可排序的，否则问题就无法求解。")]),_._v(" "),t("li",[_._v("确定状态和状态变量:将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。状 态的选择要满足无后效性。")]),_._v(" "),t("li",[_._v("确定决策并写出状态转移方程:因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段 的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常 常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。")]),_._v(" "),t("li",[_._v("寻找边界条件:给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。")])]),_._v(" "),t("h3",{attrs:{id:"_2-5-贪心算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-贪心算法"}},[_._v("#")]),_._v(" 2.5 贪心算法")]),_._v(" "),t("p",[_._v("贪心算法是指，在问题求解时，总是做出在当前看来最好的选择。也就是说，不从总体最优加以考虑，它所做出的仅是在某种意义上的局部最优解")]),_._v(" "),t("p",[_._v("贪心算法的基本思路")]),_._v(" "),t("ol",[t("li",[_._v("建立数学模型来描述问题")]),_._v(" "),t("li",[_._v("把问题分解成若干个子问题")]),_._v(" "),t("li",[_._v("对每一个子问题求解，得到子问题的局部最优解")]),_._v(" "),t("li",[_._v("把子问题的局部最优解合成原来问题的一个解")])]),_._v(" "),t("h3",{attrs:{id:"_2-6-分支界限法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-分支界限法"}},[_._v("#")]),_._v(" 2.6 分支界限法")]),_._v(" "),t("p",[_._v('所谓 "分支" 就是采用广度优先搜索算法，依次搜索节点的所有分支，抛弃不满足约束条件的节点，然后 从余下的节点中选择一个节点作为下一个搜索节点继续搜索。')]),_._v(" "),t("br"),_._v(" "),t("br"),_._v(" "),t("p",[t("strong",[_._v("参考博文")])]),_._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://leetcode-cn.com/problems/delete-middle-node-lcci/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-hua/",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://leetcode-cn.com/problems/delete-middle-node-lcci/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-hua/"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);