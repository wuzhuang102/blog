(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{296:function(t,_,v){"use strict";v.r(_);var l=v(28),a=Object(l.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"http-简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-简介"}},[t._v("#")]),t._v(" HTTP 简介")]),t._v(" "),v("p",[v("img",{attrs:{src:"/http/http-protocol.jpg",alt:"http protocol"}})]),t._v(" "),v("h2",{attrs:{id:"_1-什么是-http-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是-http-协议"}},[t._v("#")]),t._v(" 1. 什么是 HTTP 协议")]),t._v(" "),v("ul",[v("li",[t._v("HTTP 是超文本传输协议(Hypertext Transfer Protocol)，它是为 web 浏览器与 web 服务器之间通信设计的，但也可用于其他，位于 TCP/IP 协议 应用层")]),t._v(" "),v("li",[t._v("HTTP 协议是由客户机到服务器的请求 (Request) 和 从服务器到客户机的响应 (Response) 进行约束和规范")])]),t._v(" "),v("p",[t._v("Http 请求报文的组成部分")]),t._v(" "),v("ol",[v("li",[t._v("Http 请求行")]),t._v(" "),v("li",[t._v("Http 请求头")]),t._v(" "),v("li",[t._v("空行")]),t._v(" "),v("li",[t._v("请求数据")])]),t._v(" "),v("h2",{attrs:{id:"_2-tcp-ip-协议栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-tcp-ip-协议栈"}},[t._v("#")]),t._v(" 2. TCP/IP 协议栈")]),t._v(" "),v("table",[v("tr",[v("th",[t._v("ISO协议")]),t._v(" "),v("th",[t._v("TCP/IP协议")])]),t._v(" "),v("tr",[v("td",[t._v("应用层")]),t._v(" "),v("td",{attrs:{rowspan:"3"}},[t._v("应用层")])]),t._v(" "),v("tr",[v("td",[t._v("表示层")])]),t._v(" "),v("tr",[v("td",[t._v("会话层")])]),t._v(" "),v("tr",[v("td",[t._v("传输层")]),t._v(" "),v("td",[t._v("传输层")])]),t._v(" "),v("tr",[v("td",[t._v("网络层")]),t._v(" "),v("td",[t._v("网络层")])]),t._v(" "),v("tr",[v("td",[t._v("数据链路层")]),t._v(" "),v("td",{attrs:{rowspan:"2"}},[t._v("网络接口层")])]),t._v(" "),v("tr",[v("td",[t._v("物理层")])])]),t._v(" "),v("h3",{attrs:{id:"_3-tcp-ip-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-tcp-ip-协议"}},[t._v("#")]),t._v(" 3. TCP/IP 协议")]),t._v(" "),v("ol",[v("li",[t._v("应用层\n"),v("ul",[v("li",[t._v("为用户提供服务，如 HTTP 协议、FTP 协议、SSH 协议、DNS 协议、SMTP 协议等")])])]),t._v(" "),v("li",[t._v("传输层\n"),v("ul",[v("li",[t._v("给应用层实体提供端到端的通信，保证数据的传输及完整")]),t._v(" "),v("li",[t._v("该层定义了两个主要协议：传输控制协议（TCP）和 用户数据报协议（UDP）")])])]),t._v(" "),v("li",[t._v("网络层\n"),v("ul",[v("li",[t._v("主要解决主机到主机的通信问题")])])]),t._v(" "),v("li",[t._v("网络接口层\n"),v("ul",[v("li",[t._v("负责监视数据在主机和网络之间测交换")])])])]),t._v(" "),v("h3",{attrs:{id:"_4-iso-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-iso-协议"}},[t._v("#")]),t._v(" 4. ISO 协议")]),t._v(" "),v("ol",[v("li",[t._v("应用层\n"),v("ul",[v("li",[t._v("为用户提供服务，如 HTTP 协议、FTP 协议、SSH 协议、DNS 协议、SMTP 协议等")])])]),t._v(" "),v("li",[t._v("表示层\n"),v("ul",[v("li",[t._v("用于处理在两个通信系统中交换信息的表示方法，主要包括数据格式变换、数据加密解密、数据压缩与恢复等")])])]),t._v(" "),v("li",[t._v("会话层\n"),v("ul",[v("li",[t._v("负责两个节点传输连接，以便确保点到点传输不中断。管理数据交换")]),t._v(" "),v("li",[t._v("封装 HTTPS 密钥交换")])])]),t._v(" "),v("li",[t._v("传输层\n"),v("ul",[v("li",[t._v("该层定义了两个主要协议：传输控制协议（TCP）和 用户数据报协议（UDP）")])])]),t._v(" "),v("li",[t._v("网络层\n"),v("ul",[v("li",[t._v("也叫 IP 层，IP 在网络层分配。")])])]),t._v(" "),v("li",[t._v("数据链路层\n"),v("ul",[v("li",[t._v("涉及网卡（MAC 地址）")])])]),t._v(" "),v("li",[t._v("物理层\n"),v("ul",[v("li",[t._v("实际上指的是硬件、网卡等")])])])]),t._v(" "),v("h2",{attrs:{id:"_5-tcp-的三次握手与四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-tcp-的三次握手与四次挥手"}},[t._v("#")]),t._v(" 5. TCP 的三次握手与四次挥手")]),t._v(" "),v("p",[t._v("为保证传输的可靠性，三次握手是理论的最小值")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"left"}},[t._v("字段")]),t._v(" "),v("th",{staticStyle:{"text-align":"left"}},[t._v("含义")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("SYN")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("请求建立连接，并在其序列号的字段进行序列号的初始值设置。建立连接，设置为 1")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("ACK")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("确认是否有效，一般设置为 1")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("RST")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("对方要求重新连接，复位")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"left"}},[t._v("FIN")]),t._v(" "),v("td",{staticStyle:{"text-align":"left"}},[t._v("希望断开连接")])])])]),t._v(" "),v("p",[v("img",{attrs:{src:"/http/tcp-handshake.jpg",alt:""}})]),t._v(" "),v("h3",{attrs:{id:"三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),v("ol",[v("li",[t._v("客户端尝试连接服务器，向服务器发送 syn(syn = x) 包，进入 SYN_SEND 状态等待服务器确认")]),t._v(" "),v("li",[t._v("服务器接收到客户端 syn 包并确认(ack = x + 1)，同时向客户端发送一个 syn (syn = y) 包，即： syn + ack，此时服务器进入 SYN_RECV 状态，告知客户端：收到请求、随时接收。")]),t._v(" "),v("li",[t._v("客户端收到服务器的 syn 包，向服务器发送确认包 ack (ack = y + 1)，发送完毕，客户端进入 ESTBLISHED 状态，服务器接收到亦如此，三次握手完成")])]),t._v(" "),v("h3",{attrs:{id:"四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("第一次")]),t._v("：客户端发出连接释放报文，并停止发送数据。FIN = 1,序列号为 seq = u, 此时客户端进入 FIN-WAIT-1 状态")]),t._v(" "),v("li",[v("strong",[t._v("第二次")]),t._v("：服务器收到释放报文，发出确认报文，ACK = 1, ack = u + 1 ,并带上自己的序列号 seq = v，服务端进入 CLOSE-WAIT 状态")]),t._v(" "),v("li",[t._v("客户端收到服务器确认请求后，此时客户端就进入 FIN—WAIT-2 状态，等待服务器发送连接释放报文")]),t._v(" "),v("li",[v("strong",[t._v("第三次")]),t._v("：服务器发送一个 FIN = 1，ack = u + 1 ，此时服务器进入 LAST-ACK 状态，等待服务器确认.假定此时序列号为 seq = w")]),t._v(" "),v("li",[v("strong",[t._v("第四次")]),t._v("：客户端收到释放报文，必须发出确认，ACK=1，ack = w +1，客户端进入 TIME-WAIT 状态此时还没有释放 TCP 连接，必须经过 2**MSL(最长报文寿命时间),客户端撤销 TCP 才进入 CLOSED")]),t._v(" "),v("li",[t._v("服务端接收到客户端发送的确认，直接进入 CLOSEd 状态")])]),t._v(" "),v("h3",{attrs:{id:"为什么握手是三次，挥手却是四次"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么握手是三次，挥手却是四次"}},[t._v("#")]),t._v(" 为什么握手是三次，挥手却是四次")]),t._v(" "),v("p",[t._v("这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。")]),t._v(" "),v("h2",{attrs:{id:"_6-http-的工作过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-http-的工作过程"}},[t._v("#")]),t._v(" 6. HTTP 的工作过程")]),t._v(" "),v("ol",[v("li",[t._v("客户机与服务器建立连接")]),t._v(" "),v("li",[t._v("建立连接后，客户机发送一个请求给服务器，请求格式为：统一资源标识符(URL)、协议版本号，后面是 MIME 信息包括请求修饰符、客户机信息和可能的内容。")]),t._v(" "),v("li",[t._v("服务器接收到请求后，给予相应的响应信息，其格式为状态行，包括协议的版本号、一个成功或错误的代码，后面是 MIME 信息包括服务器信息、实体信息和可能的内容。")]),t._v(" "),v("li",[t._v("客户机接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后与服务器断开连接。")])]),t._v(" "),v("p",[t._v("以上任何一步出错，产生的错误信息将返回到客户端。")]),t._v(" "),v("h2",{attrs:{id:"_7-http2-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-http2-0"}},[t._v("#")]),t._v(" 7. HTTP2.0")]),t._v(" "),v("h3",{attrs:{id:"_1-http2-0-与-http1-x-相比的新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-http2-0-与-http1-x-相比的新特性"}},[t._v("#")]),t._v(" 1. Http2.0 与 Http1.x 相比的新特性")]),t._v(" "),v("ol",[v("li",[t._v("Http1.x 解析是基于文本的，Http2.0 解析是基于二进制的")]),t._v(" "),v("li",[t._v("多路复用\n"),v("ul",[v("li",[t._v("http1.x 每个 http 请求都会建立一次 tcp 链接，且浏览器限制同一域名下并发请求的个数")]),t._v(" "),v("li",[t._v("http2.0 下，所有的请求公用一个 tcp 连接")]),t._v(" "),v("li",[t._v("接收方可以根据 request 的 id 将 request 归属到不同的请求里")])])]),t._v(" "),v("li",[t._v("请求优先级\n"),v("ul",[v("li",[t._v("每个请求都会有优先级")])])]),t._v(" "),v("li",[t._v("Header 压缩\n"),v("ul",[v("li",[t._v("服务端、客户端共同维护一套静态字典，记录出现过的 header")])])]),t._v(" "),v("li",[t._v("服务端 push\n"),v("ul",[v("li",[t._v("服务端可以在客户端的某个请求后，根据这个请求，主动推送其它资源")])])])]),t._v(" "),v("h3",{attrs:{id:"_2-http2-0-的多路复用和-http1-x-的长连接复用有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-http2-0-的多路复用和-http1-x-的长连接复用有什么区别"}},[t._v("#")]),t._v(" 2. Http2.0 的多路复用和 Http1.x 的长连接复用有什么区别")]),t._v(" "),v("ul",[v("li",[t._v("http1.x 一个请求、一个响应，用完关闭")]),t._v(" "),v("li",[t._v("http1.x pipelnig，若干请求排队串行化单线程处理，耗时任务会堵塞后续请求")]),t._v(" "),v("li",[t._v("http2.0 多个请求可在一个连接上并行执行，耗时任务不会影响其它连接执行")])]),t._v(" "),v("h2",{attrs:{id:"_8-http3-0"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-http3-0"}},[t._v("#")]),t._v(" 8. HTTP3.0")]),t._v(" "),v("p",[t._v("HTTP3.0 是基于 UDP 的安全可靠的 HTTP2.0 协议")]),t._v(" "),v("ol",[v("li",[t._v("减少了 TCP 三次握手及 TLS 握手时间")]),t._v(" "),v("li",[t._v("多路复用丢包时没有线头阻塞问题\n"),v("ul",[v("li",[t._v("QUIC 中的一个连接上的多个 stream 之间没有依赖关系，发生丢包时，只会影响当前 stream，但是需要重发需要确认")])])]),t._v(" "),v("li",[t._v("优化重传策略\n"),v("ul",[v("li",[t._v("TCP 重传策略：发送端为每一个包记一个编号，接收端收到包时将编号发送给服务端，表示已收到，一定时间没传表示未收到，就会重传，id 还和之前一样，发送端后续就需要")]),t._v(" "),v("li",[t._v("QUIC 发送包时的每一个编号都是严格递增的编号，重传的包就可以确认是初始封包还是重传封包")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);