(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{396:function(t,_,v){"use strict";v.r(_);var a=v(28),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"linux-异步机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#linux-异步机制"}},[t._v("#")]),t._v(" Linux --- 异步机制")]),t._v(" "),v("h2",{attrs:{id:"linux-相关概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#linux-相关概念"}},[t._v("#")]),t._v(" Linux 相关概念")]),t._v(" "),v("p",[t._v("了解 Linux 的异步机制之前让我们来了解以下一些 Linux 的相关知识")]),t._v(" "),v("h3",{attrs:{id:"_1-linux整体架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-linux整体架构"}},[t._v("#")]),t._v(" 1. "),v("a",{attrs:{href:"/tool/linux/base"}},[t._v("Linux整体架构")])]),t._v(" "),v("h3",{attrs:{id:"_2-用户态与内核态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-用户态与内核态"}},[t._v("#")]),t._v(" 2. 用户态与内核态")]),t._v(" "),v("h4",{attrs:{id:"内核态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内核态"}},[t._v("#")]),t._v(" 内核态")]),t._v(" "),v("p",[t._v("当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行状态（内核态）")]),t._v(" "),v("ul",[v("li",[t._v("当进程处于内核态，执行的内核代码会使用当前进程的内核栈")])]),t._v(" "),v("h4",{attrs:{id:"用户态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户态"}},[t._v("#")]),t._v(" 用户态")]),t._v(" "),v("p",[t._v("当任务（进程）在执行用户自己的代码时，则称其处于用户运行态（用户态）")]),t._v(" "),v("h4",{attrs:{id:"用户态与内核态存在的原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户态与内核态存在的原因"}},[t._v("#")]),t._v(" 用户态与内核态存在的原因")]),t._v(" "),v("p",[t._v("CPU的所有指令中，有些是非常危险的，如果错用可能导致整个系统的崩溃。对于这些指令，只允许操作系统及其相关模块使用，普通的应用程序只能使用那些不会造成灾难的指令。")]),t._v(" "),v("h4",{attrs:{id:"cpu总处于以下三种状态之一"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cpu总处于以下三种状态之一"}},[t._v("#")]),t._v(" CPU总处于以下三种状态之一")]),t._v(" "),v("ul",[v("li",[t._v("运行于用户空间，执行用户进程")]),t._v(" "),v("li",[t._v("运行于内核空间，处于进程上下文，代表某个特定的进程执行")]),t._v(" "),v("li",[t._v("运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断")])]),t._v(" "),v("h3",{attrs:{id:"_3-linux的信号机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-linux的信号机制"}},[t._v("#")]),t._v(" 3. Linux的信号机制")]),t._v(" "),v("h4",{attrs:{id:"软中断信号（signal，信号）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软中断信号（signal，信号）"}},[t._v("#")]),t._v(" 软中断信号（signal，信号）")]),t._v(" "),v("ul",[v("li",[t._v("用来通知进程发生了异步事件。进程之间可以通过系统调用 kill 发送中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。")]),t._v(" "),v("li",[t._v("信号知识用来通知某个进程发生了什么事件，并不给该进程传递任何数据")])]),t._v(" "),v("h4",{attrs:{id:"对信号的处理方法（收到信号后）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#对信号的处理方法（收到信号后）"}},[t._v("#")]),t._v(" 对信号的处理方法（收到信号后）")]),t._v(" "),v("ol",[v("li",[t._v("对于需要处理的信号，进程可以指定处理函数，由该函数来处理")]),t._v(" "),v("li",[t._v("忽略某个信号，对该信号不做任何处理，就像未发生过一样，有两个信号不能忽略 SIGKILL 和 SIGSTOP")]),t._v(" "),v("li",[t._v("对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。")])]),t._v(" "),v("p",[v("em",[t._v("内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时")]),t._v("。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时处理。\n进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号")]),t._v(" "),v("h2",{attrs:{id:"linux-io-模型的简单矩阵"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#linux-io-模型的简单矩阵"}},[t._v("#")]),t._v(" Linux IO 模型的简单矩阵")]),t._v(" "),v("table",{staticClass:"async-table"},[v("tr",[v("th"),t._v(" "),v("th",[t._v("Blocking")]),t._v(" "),v("th",[t._v("Non-blocking")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"font-weight":"700"}},[t._v("Synchronous")]),t._v(" "),v("td",[t._v("Read/Write")]),t._v(" "),v("td",[t._v("Read/Write "),v("br"),t._v(" (O_NONBLOCK)")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"font-weight":"700"}},[t._v("Asynchronous")]),t._v(" "),v("td",[t._v("I/O multiplexing "),v("br"),t._v(" (select/poll)")]),t._v(" "),v("td",[t._v("AIO")])])]),t._v(" "),v("style",[t._v("\n.async-table th,td {\n    width: 160px;\n    height: 50px;\n    text-align: center;\n}\n")]),t._v(" "),v("ul",[v("li",[t._v("同步：处理消息者自己去等待消息是否被触发")]),t._v(" "),v("li",[t._v("异步：触发机制来通知处理消息者")]),t._v(" "),v("li",[t._v("阻塞：线程挂起，不能做其他事")]),t._v(" "),v("li",[t._v("非阻塞：线程活跃，可以做其他事")])]),t._v(" "),v("h3",{attrs:{id:"_1-同步阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-同步阻塞"}},[t._v("#")]),t._v(" 1. 同步阻塞")]),t._v(" "),v("ul",[v("li",[t._v("用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞。直到系统调用完成为止（数据传输完成或发生错误）")]),t._v(" "),v("li",[t._v("调用应用程序处于一种不再消费CPU而只是简单等待响应的状态")]),t._v(" "),v("li",[t._v("从处理器的角度来看，这是非常有效的")])]),t._v(" "),v("h3",{attrs:{id:"_2-同步非阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-同步非阻塞"}},[t._v("#")]),t._v(" 2. 同步非阻塞")]),t._v(" "),v("ul",[v("li",[t._v("同步阻塞I/O 的一种变体是效率较低的同步非阻塞 I/O")]),t._v(" "),v("li",[t._v("非阻塞意味着如果 I/O 操作不能立即完成，则需要应用程序多次调用直到任务完成")]),t._v(" "),v("li",[t._v("这种模式可能比较低效，因为大多数程序必须等待或者尝试做其他事情直到数据可用")])]),t._v(" "),v("h3",{attrs:{id:"_3-异步阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-异步阻塞"}},[t._v("#")]),t._v(" 3. 异步阻塞")]),t._v(" "),v("ul",[v("li",[t._v("带有阻塞通知的非阻塞I/O ： I/O 是非阻塞的，然后使用阻塞 "),v("code",[t._v("select")]),t._v(" 系统调用来确定一个 I/O 描述符何时有操作")]),t._v(" "),v("li",[v("code",[t._v("select")]),t._v(" 系统最大的好处是可以监听多个描述符，而且可以指定每个描述符要监听的事件：可读、可写和发生错误事件")]),t._v(" "),v("li",[v("code",[t._v("select")]),t._v(" 系统最主要的问题是效率不高，它是非常方便的异步通知模型，但不建议用于高性能 I/O 中，高性能使用 "),v("code",[t._v("epoll")])])]),t._v(" "),v("h4",{attrs:{id:"select"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[t._v("#")]),t._v(" select")]),t._v(" "),v("ul",[v("li",[t._v("select 模型的关键是使用一种有序的方式，对多个套接字进程统一管理与调度")]),t._v(" "),v("li",[t._v("缺点\n"),v("ul",[v("li",[t._v("单个进程能够监视的文件描述符存在最大限制，通常是1024，可更改。select采用轮询的方式扫描文件描述符，文件描述越多，性能越差")]),t._v(" "),v("li",[t._v("内核/用户空间内存拷贝问题。select 需要复制大量的具柄数据结构，产生巨大的开销")]),t._v(" "),v("li",[t._v("select 返回的是整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件")]),t._v(" "),v("li",[t._v("select 的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后的每次 select 调用还是会讲这些文件描述符通知进程")])])]),t._v(" "),v("li",[t._v("现在的 select 模型基本已被 AIO 取代了")])]),t._v(" "),v("h4",{attrs:{id:"epoll"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#epoll"}},[t._v("#")]),t._v(" epoll")]),t._v(" "),v("ul",[v("li",[t._v("优点\n"),v("ul",[v("li",[t._v("支持一个进程打开大数目的 socket 描述符")]),t._v(" "),v("li",[t._v("IO 效率不随 FD 数目增加而线性下降")]),t._v(" "),v("li",[t._v("使用 mermory map 加速内核 与 用户空间 的消息传递")])])])]),t._v(" "),v("h4",{attrs:{id:"iocp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#iocp"}},[t._v("#")]),t._v(" IOCP")]),t._v(" "),v("p",[t._v("windows 下的一种模型")]),t._v(" "),v("h3",{attrs:{id:"_4-异步非阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-异步非阻塞"}},[t._v("#")]),t._v(" 4. 异步非阻塞")]),t._v(" "),v("ul",[v("li",[t._v("它可以并行处理 I/O 的模型")]),t._v(" "),v("li",[t._v("异步非阻塞 I/O 模型的请求会立即返回，表明读操作成功启动。然后程序就可以在读操作完成之前做其他的事情。当读操作完成时，内核可以通过 "),v("em",[t._v("信号")]),t._v(" 或者 "),v("em",[t._v("基于线程的回调")]),t._v("来通知应用程序读取数据")]),t._v(" "),v("li",[t._v("单个进程可以并行执行多个 I/O 请求是因为 CPU 的处理速度要远大于 I/O 的处理速度。当一个或多个 I/O 请求在等待处理时，CPU可以处理其他任务或者处理其他已完成的 I/O 请求")])])])}),[],!1,null,null,null);_.default=s.exports}}]);