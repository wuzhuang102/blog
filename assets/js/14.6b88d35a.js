(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{268:function(e,t,r){"use strict";r.r(t);var a=r(28),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"算法总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法总结"}},[e._v("#")]),e._v(" 算法总结")]),e._v(" "),r("h2",{attrs:{id:"_1-链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-链表"}},[e._v("#")]),e._v(" 1. 链表")]),e._v(" "),r("h3",{attrs:{id:"_1-1-双指针问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-双指针问题"}},[e._v("#")]),e._v(" 1.1 双指针问题")]),e._v(" "),r("p",[e._v("双指针的问题本质上也可以用 "),r("code",[e._v("哈希表")]),e._v(" 解决，但双指针更有效，空间复杂度为 "),r("code",[e._v("O(1)")]),e._v("，我们所需要考虑的问题就是两个指针的速度问题")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/linked-list/jbex5/",target:"_blank",rel:"noopener noreferrer"}},[e._v("是否有环形链表"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/linked-list/jjhf6/",target:"_blank",rel:"noopener noreferrer"}},[e._v("环形链表起始位置"),r("OutboundLink")],1),e._v("：考虑双指针的速度和路程问题")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/linked-list/jjbj2/",target:"_blank",rel:"noopener noreferrer"}},[e._v("相交链表"),r("OutboundLink")],1),e._v("：本质上也是环形链表逻辑")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/linked-list/jf1cc/",target:"_blank",rel:"noopener noreferrer"}},[e._v("删除倒数第N个节点"),r("OutboundLink")],1)])]),e._v(" "),r("h3",{attrs:{id:"_1-2-经典问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-经典问题"}},[e._v("#")]),e._v(" 1.2 经典问题")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/linked-list/f58sg/",target:"_blank",rel:"noopener noreferrer"}},[e._v("链表反转"),r("OutboundLink")],1),e._v("：递归和迭代都可以使用")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/linked-list/fe0kj/",target:"_blank",rel:"noopener noreferrer"}},[e._v("奇偶链表"),r("OutboundLink")],1),e._v("：奇偶单独抽出再合并")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/linked-list/fov6t/",target:"_blank",rel:"noopener noreferrer"}},[e._v("回文链表"),r("OutboundLink")],1),e._v("：回文可以利用数组双向遍历，也可以将链表后半部分反转再进行对比")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/linked-list/fv6w7/",target:"_blank",rel:"noopener noreferrer"}},[e._v("两数相加"),r("OutboundLink")],1),e._v("：利用链表模拟加法运算")])]),e._v(" "),r("h2",{attrs:{id:"_2-树、二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-树、二叉树"}},[e._v("#")]),e._v(" 2. 树、二叉树")]),e._v(" "),r("h3",{attrs:{id:"_2-1-二叉树的遍历"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-二叉树的遍历"}},[e._v("#")]),e._v(" 2.1 二叉树的遍历")]),e._v(" "),r("p",[e._v("前、中、后是相对于根节点访问顺序而言")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xeywh5/",target:"_blank",rel:"noopener noreferrer"}},[e._v("前序遍历"),r("OutboundLink")],1),e._v("：先访问根节点，再访问左子树，最后访问右子树")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xecaj6/",target:"_blank",rel:"noopener noreferrer"}},[e._v("中序遍历"),r("OutboundLink")],1),e._v("：先遍历左子树，再访问根节点，最后访问右子树")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xebrb2/",target:"_blank",rel:"noopener noreferrer"}},[e._v("后序遍历"),r("OutboundLink")],1),e._v("：先遍历右子树，再遍历右子树，最后访问根节点")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xefh1i/",target:"_blank",rel:"noopener noreferrer"}},[e._v("层序遍历"),r("OutboundLink")],1),e._v("：逐层遍历树结构\n"),r("ul",[r("li",[e._v("算法思想：遍历子树时，合理利用数组，确定当前遍历的深度")])])])]),e._v(" "),r("h3",{attrs:{id:"_2-2-利用递归解决问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-利用递归解决问题"}},[e._v("#")]),e._v(" 2.2 利用递归解决问题")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoxzgv/",target:"_blank",rel:"noopener noreferrer"}},[e._v("对称二叉树"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/xoh1zg/",target:"_blank",rel:"noopener noreferrer"}},[e._v("最大深度"),r("OutboundLink")],1)])]),e._v(" "),r("h2",{attrs:{id:"_3-二叉搜索树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-二叉搜索树"}},[e._v("#")]),e._v(" 3. 二叉搜索树")]),e._v(" "),r("h3",{attrs:{id:"_3-1-二叉搜索树简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-二叉搜索树简介"}},[e._v("#")]),e._v(" 3.1 二叉搜索树简介")]),e._v(" "),r("ul",[r("li",[e._v("什么是二叉搜索树(Binary Search Tree - BST)\n"),r("ul",[r("li",[e._v("每个节点中的值必须 "),r("code",[e._v(">=")]),e._v(" 其左侧节点中的任何值")]),e._v(" "),r("li",[e._v("每个节点中的值必须 "),r("code",[e._v("<=")]),e._v("  其右侧节点中的任何值")])])]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/introduction-to-data-structure-binary-search-tree/xpkc6i/",target:"_blank",rel:"noopener noreferrer"}},[e._v("二叉搜索树验证"),r("OutboundLink")],1),e._v("：二叉搜索树验证的主要思想就是中序遍历")])]),e._v(" "),r("h3",{attrs:{id:"_3-2-二叉搜索树中的基本操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-二叉搜索树中的基本操作"}},[e._v("#")]),e._v(" 3.2 二叉搜索树中的基本操作")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/introduction-to-data-structure-binary-search-tree/xpsqtv/",target:"_blank",rel:"noopener noreferrer"}},[e._v("搜索"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/introduction-to-data-structure-binary-search-tree/xp1llt/",target:"_blank",rel:"noopener noreferrer"}},[e._v("插入"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://leetcode-cn.com/leetbook/read/introduction-to-data-structure-binary-search-tree/xpcnds/",target:"_blank",rel:"noopener noreferrer"}},[e._v("删除"),r("OutboundLink")],1),e._v(" "),r("ul",[r("li",[e._v("核心思想是迭代将对应的 TreeNode 返回给前驱节点\n"),r("ul",[r("li",[e._v("如果该节点是叶子节点，直接返回 null")]),e._v(" "),r("li",[e._v("如果该节点有右子树，则找到右子树中最小的值（后驱节点）做替换，并删除对应节点")]),e._v(" "),r("li",[e._v("如果该节点只有左子树，则找到左子树中最大的值（前驱节点）做替换，并删除对应节点")])])])])])])])}),[],!1,null,null,null);t.default=o.exports}}]);