<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>你不知道的JavaScript(上) | 你当像鸟飞往你的山</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/avatar.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.2464540b.css" as="style"><link rel="preload" href="/assets/js/app.52282d9c.js" as="script"><link rel="preload" href="/assets/js/2.b2576fa9.js" as="script"><link rel="preload" href="/assets/js/21.875ef651.js" as="script"><link rel="prefetch" href="/assets/js/10.0be33358.js"><link rel="prefetch" href="/assets/js/100.716ebdc8.js"><link rel="prefetch" href="/assets/js/101.58e245f4.js"><link rel="prefetch" href="/assets/js/102.6d030de1.js"><link rel="prefetch" href="/assets/js/103.9f505b69.js"><link rel="prefetch" href="/assets/js/104.36a96edc.js"><link rel="prefetch" href="/assets/js/105.12e8a7b4.js"><link rel="prefetch" href="/assets/js/106.0c84fec3.js"><link rel="prefetch" href="/assets/js/107.dd8cc792.js"><link rel="prefetch" href="/assets/js/108.7323b4b2.js"><link rel="prefetch" href="/assets/js/109.96f90cf3.js"><link rel="prefetch" href="/assets/js/11.9a521f7e.js"><link rel="prefetch" href="/assets/js/110.139fc8a3.js"><link rel="prefetch" href="/assets/js/111.72b6e215.js"><link rel="prefetch" href="/assets/js/112.3e4783dd.js"><link rel="prefetch" href="/assets/js/113.cb5580ff.js"><link rel="prefetch" href="/assets/js/114.1fdeaea5.js"><link rel="prefetch" href="/assets/js/115.6030aed1.js"><link rel="prefetch" href="/assets/js/116.16d6c0b6.js"><link rel="prefetch" href="/assets/js/117.111259b4.js"><link rel="prefetch" href="/assets/js/118.62ff8a4a.js"><link rel="prefetch" href="/assets/js/119.cfcc05c7.js"><link rel="prefetch" href="/assets/js/12.f372d0c6.js"><link rel="prefetch" href="/assets/js/120.b5e9efe6.js"><link rel="prefetch" href="/assets/js/121.c06b5975.js"><link rel="prefetch" href="/assets/js/122.2fdcaf63.js"><link rel="prefetch" href="/assets/js/123.67a72bd2.js"><link rel="prefetch" href="/assets/js/124.852cf569.js"><link rel="prefetch" href="/assets/js/125.a504f556.js"><link rel="prefetch" href="/assets/js/126.8debc763.js"><link rel="prefetch" href="/assets/js/127.1f3ac6f8.js"><link rel="prefetch" href="/assets/js/128.c58d7f07.js"><link rel="prefetch" href="/assets/js/129.007dd18d.js"><link rel="prefetch" href="/assets/js/13.8471e0ab.js"><link rel="prefetch" href="/assets/js/130.820639be.js"><link rel="prefetch" href="/assets/js/131.ef9f9a27.js"><link rel="prefetch" href="/assets/js/132.9375a12d.js"><link rel="prefetch" href="/assets/js/133.65b1660f.js"><link rel="prefetch" href="/assets/js/134.68277f88.js"><link rel="prefetch" href="/assets/js/135.3a417fc0.js"><link rel="prefetch" href="/assets/js/136.ad3d0bf5.js"><link rel="prefetch" href="/assets/js/137.98c1cf0c.js"><link rel="prefetch" href="/assets/js/138.0bdf95bb.js"><link rel="prefetch" href="/assets/js/139.ce6661e8.js"><link rel="prefetch" href="/assets/js/14.6b88d35a.js"><link rel="prefetch" href="/assets/js/140.f09d07e2.js"><link rel="prefetch" href="/assets/js/141.083920e3.js"><link rel="prefetch" href="/assets/js/142.80ec6b60.js"><link rel="prefetch" href="/assets/js/143.4f6fd155.js"><link rel="prefetch" href="/assets/js/144.70ebb78b.js"><link rel="prefetch" href="/assets/js/145.87d82f0e.js"><link rel="prefetch" href="/assets/js/146.501a8306.js"><link rel="prefetch" href="/assets/js/147.c7ca19a7.js"><link rel="prefetch" href="/assets/js/148.f11992a1.js"><link rel="prefetch" href="/assets/js/149.90711701.js"><link rel="prefetch" href="/assets/js/15.bbf26fd6.js"><link rel="prefetch" href="/assets/js/150.0fe91c80.js"><link rel="prefetch" href="/assets/js/151.eba738f9.js"><link rel="prefetch" href="/assets/js/152.ed08d6e0.js"><link rel="prefetch" href="/assets/js/153.57e98815.js"><link rel="prefetch" href="/assets/js/154.6ed7b2b2.js"><link rel="prefetch" href="/assets/js/155.c4f48247.js"><link rel="prefetch" href="/assets/js/156.5bbe6c7f.js"><link rel="prefetch" href="/assets/js/157.c6343f69.js"><link rel="prefetch" href="/assets/js/158.58967568.js"><link rel="prefetch" href="/assets/js/159.efda2d6a.js"><link rel="prefetch" href="/assets/js/16.c07ff42a.js"><link rel="prefetch" href="/assets/js/160.ced00468.js"><link rel="prefetch" href="/assets/js/161.f4cccfbe.js"><link rel="prefetch" href="/assets/js/162.9115d694.js"><link rel="prefetch" href="/assets/js/163.bac22cf3.js"><link rel="prefetch" href="/assets/js/164.26c7de09.js"><link rel="prefetch" href="/assets/js/165.4581cbc1.js"><link rel="prefetch" href="/assets/js/166.42062541.js"><link rel="prefetch" href="/assets/js/167.7c752121.js"><link rel="prefetch" href="/assets/js/168.ec10a223.js"><link rel="prefetch" href="/assets/js/169.1e71713e.js"><link rel="prefetch" href="/assets/js/17.6b1aaf25.js"><link rel="prefetch" href="/assets/js/170.8674d04e.js"><link rel="prefetch" href="/assets/js/171.659ddd64.js"><link rel="prefetch" href="/assets/js/172.fc927677.js"><link rel="prefetch" href="/assets/js/173.effa59d0.js"><link rel="prefetch" href="/assets/js/18.6a53e8bd.js"><link rel="prefetch" href="/assets/js/19.070948a0.js"><link rel="prefetch" href="/assets/js/20.4eab5b4b.js"><link rel="prefetch" href="/assets/js/22.3016600a.js"><link rel="prefetch" href="/assets/js/23.2bceca16.js"><link rel="prefetch" href="/assets/js/24.5ca1a949.js"><link rel="prefetch" href="/assets/js/25.7128f5f5.js"><link rel="prefetch" href="/assets/js/26.2bab6302.js"><link rel="prefetch" href="/assets/js/27.63ee87cc.js"><link rel="prefetch" href="/assets/js/28.0f585b16.js"><link rel="prefetch" href="/assets/js/29.9b1a6733.js"><link rel="prefetch" href="/assets/js/3.cf3e2a61.js"><link rel="prefetch" href="/assets/js/30.0d7f9099.js"><link rel="prefetch" href="/assets/js/31.935ab8aa.js"><link rel="prefetch" href="/assets/js/32.a1046d11.js"><link rel="prefetch" href="/assets/js/33.ca4a9ecf.js"><link rel="prefetch" href="/assets/js/34.fffbe11c.js"><link rel="prefetch" href="/assets/js/35.457e82c7.js"><link rel="prefetch" href="/assets/js/36.ef0a87d5.js"><link rel="prefetch" href="/assets/js/37.1cbbc372.js"><link rel="prefetch" href="/assets/js/38.7e33d6f3.js"><link rel="prefetch" href="/assets/js/39.6904d709.js"><link rel="prefetch" href="/assets/js/4.612c2b09.js"><link rel="prefetch" href="/assets/js/40.c6325732.js"><link rel="prefetch" href="/assets/js/41.b56dca91.js"><link rel="prefetch" href="/assets/js/42.b51db9ce.js"><link rel="prefetch" href="/assets/js/43.8a53c7ca.js"><link rel="prefetch" href="/assets/js/44.f495304f.js"><link rel="prefetch" href="/assets/js/45.4ebd10b5.js"><link rel="prefetch" href="/assets/js/46.5f62cc4b.js"><link rel="prefetch" href="/assets/js/47.578287ae.js"><link rel="prefetch" href="/assets/js/48.a70765fd.js"><link rel="prefetch" href="/assets/js/49.9eb21dfb.js"><link rel="prefetch" href="/assets/js/5.c1b1c539.js"><link rel="prefetch" href="/assets/js/50.69028fff.js"><link rel="prefetch" href="/assets/js/51.2231d361.js"><link rel="prefetch" href="/assets/js/52.aee41e86.js"><link rel="prefetch" href="/assets/js/53.869c8d27.js"><link rel="prefetch" href="/assets/js/54.a63e70db.js"><link rel="prefetch" href="/assets/js/55.91e3e20a.js"><link rel="prefetch" href="/assets/js/56.43b2de29.js"><link rel="prefetch" href="/assets/js/57.b64f6ec9.js"><link rel="prefetch" href="/assets/js/58.77d56ca3.js"><link rel="prefetch" href="/assets/js/59.3d69886d.js"><link rel="prefetch" href="/assets/js/6.22dc9a23.js"><link rel="prefetch" href="/assets/js/60.d083cc6a.js"><link rel="prefetch" href="/assets/js/61.6fa3b2c2.js"><link rel="prefetch" href="/assets/js/62.69bb327e.js"><link rel="prefetch" href="/assets/js/63.24b7de60.js"><link rel="prefetch" href="/assets/js/64.1864f6c1.js"><link rel="prefetch" href="/assets/js/65.e379a5a4.js"><link rel="prefetch" href="/assets/js/66.7d214662.js"><link rel="prefetch" href="/assets/js/67.6032cb0e.js"><link rel="prefetch" href="/assets/js/68.8750df23.js"><link rel="prefetch" href="/assets/js/69.e95607f5.js"><link rel="prefetch" href="/assets/js/7.6ba5400f.js"><link rel="prefetch" href="/assets/js/70.cab3055c.js"><link rel="prefetch" href="/assets/js/71.0c74e7b5.js"><link rel="prefetch" href="/assets/js/72.6e65ef8b.js"><link rel="prefetch" href="/assets/js/73.11090e3d.js"><link rel="prefetch" href="/assets/js/74.8e491969.js"><link rel="prefetch" href="/assets/js/75.7a950686.js"><link rel="prefetch" href="/assets/js/76.0a93f202.js"><link rel="prefetch" href="/assets/js/77.d266642a.js"><link rel="prefetch" href="/assets/js/78.5d0939c8.js"><link rel="prefetch" href="/assets/js/79.773a6b91.js"><link rel="prefetch" href="/assets/js/8.59a26cd5.js"><link rel="prefetch" href="/assets/js/80.1f7745ae.js"><link rel="prefetch" href="/assets/js/81.042df0fe.js"><link rel="prefetch" href="/assets/js/82.98d41715.js"><link rel="prefetch" href="/assets/js/83.cd9dc09e.js"><link rel="prefetch" href="/assets/js/84.801d68d1.js"><link rel="prefetch" href="/assets/js/85.f7ba5a83.js"><link rel="prefetch" href="/assets/js/86.0623bd6d.js"><link rel="prefetch" href="/assets/js/87.255eb8d0.js"><link rel="prefetch" href="/assets/js/88.002727e3.js"><link rel="prefetch" href="/assets/js/89.e403f424.js"><link rel="prefetch" href="/assets/js/9.ad368501.js"><link rel="prefetch" href="/assets/js/90.d7922422.js"><link rel="prefetch" href="/assets/js/91.52d787e9.js"><link rel="prefetch" href="/assets/js/92.d82baf83.js"><link rel="prefetch" href="/assets/js/93.067df34d.js"><link rel="prefetch" href="/assets/js/94.4821f9a9.js"><link rel="prefetch" href="/assets/js/95.f21786f2.js"><link rel="prefetch" href="/assets/js/96.d10c4ddd.js"><link rel="prefetch" href="/assets/js/97.14aa246f.js"><link rel="prefetch" href="/assets/js/98.cdf8969c.js"><link rel="prefetch" href="/assets/js/99.ed247395.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2464540b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">你当像鸟飞往你的山</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/wiki/" class="nav-link">
  我的wiki
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  技术扩展
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/wiki/" class="nav-link">
  我的wiki
</a></div><div class="nav-item"><a href="/tool/" class="nav-link">
  技术扩展
</a></div><div class="nav-item"><a href="/book/" class="nav-link router-link-active">
  阅读
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>技术类</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/book/code/you_dont_know_javascript_1.html" class="active sidebar-link">你不知道的JavaScript(上)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_1-作用域是什么" class="sidebar-link">1. 作用域是什么</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_1-1-编译原理" class="sidebar-link">1.1 编译原理</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_1-2-理解作用域" class="sidebar-link">1.2 理解作用域</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_1-3-嵌套作用域" class="sidebar-link">1.3 嵌套作用域</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_1-4-异常" class="sidebar-link">1.4 异常</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_2-词法作用域" class="sidebar-link">2. 词法作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_2-1-词法阶段" class="sidebar-link">2.1 词法阶段</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_2-2-欺骗词法" class="sidebar-link">2.2 欺骗词法</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_3-函数作用域和块作用域" class="sidebar-link">3. 函数作用域和块作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_3-1-函数中的作用域" class="sidebar-link">3.1 函数中的作用域</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_3-2-隐藏内部实现" class="sidebar-link">3.2 隐藏内部实现</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_3-3-函数作用域" class="sidebar-link">3.3 函数作用域</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_3-4-块作用域" class="sidebar-link">3.4 块作用域</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_4-提升" class="sidebar-link">4. 提升</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_4-1-先有鸡还是现有蛋" class="sidebar-link">4.1 先有鸡还是现有蛋</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_4-2-编译器再度来袭" class="sidebar-link">4.2 编译器再度来袭</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_4-3-函数优先" class="sidebar-link">4.3 函数优先</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-作用域闭包" class="sidebar-link">5. 作用域闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-1-启示" class="sidebar-link">5.1 启示</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-2-实质问题" class="sidebar-link">5.2 实质问题</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-3-现在我懂了" class="sidebar-link">5.3 现在我懂了</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-4-循环和闭包" class="sidebar-link">5.4 循环和闭包</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-5-模块" class="sidebar-link">5.5 模块</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_1-关于this" class="sidebar-link">1. 关于this</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_1-1-为什么要用this" class="sidebar-link">1.1 为什么要用this</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_1-2-误解" class="sidebar-link">1.2 误解</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_1-3-this到底是什么" class="sidebar-link">1.3 this到底是什么</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_2-this全面解析" class="sidebar-link">2. this全面解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_2-1-调用位置" class="sidebar-link">2.1 调用位置</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_2-2-绑定规则" class="sidebar-link">2.2 绑定规则</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_2-4-绑定例外" class="sidebar-link">2.4 绑定例外</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_2-5-this词法" class="sidebar-link">2.5 this词法</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_3-对象" class="sidebar-link">3. 对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_3-2-类型" class="sidebar-link">3.2 类型</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_3-3-内容" class="sidebar-link">3.3 内容</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_3-4-遍历" class="sidebar-link">3.4 遍历</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_4-混合对象-类" class="sidebar-link">4. 混合对象“类”</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-原型" class="sidebar-link">5. 原型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-1-prototype" class="sidebar-link">5.1 [[prototype]]</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-2-类" class="sidebar-link">5.2 类</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-3-（原型）继承" class="sidebar-link">5.3 （原型）继承</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_5-4-对象关联" class="sidebar-link">5.4 对象关联</a></li></ul></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_6-行为委托" class="sidebar-link">6. 行为委托</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_6-1-面向委托的设计" class="sidebar-link">6.1 面向委托的设计</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_6-2-类与对象" class="sidebar-link">6.2 类与对象</a></li><li class="sidebar-sub-header"><a href="/book/code/you_dont_know_javascript_1.html#_6-3-更简洁的设计" class="sidebar-link">6.3 更简洁的设计</a></li></ul></li></ul></li><li><a href="/book/code/you_dont_know_javascript_2.html" class="sidebar-link">你不知道的JavaScript(中)</a></li><li><a href="/book/code/you_dont_know_javascript_3.html" class="sidebar-link">你不知道的JavaScript(下)</a></li><li><a href="/book/code/learning_javascript_data_structure_and_algorithms.html" class="sidebar-link">学习JavaScript数据结构与算法</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="你不知道的javascript-上"><a href="#你不知道的javascript-上" class="header-anchor">#</a> 你不知道的JavaScript(上)</h1> <h1 id="第一部分"><a href="#第一部分" class="header-anchor">#</a> 第一部分</h1> <h2 id="_1-作用域是什么"><a href="#_1-作用域是什么" class="header-anchor">#</a> 1. 作用域是什么</h2> <h3 id="_1-1-编译原理"><a href="#_1-1-编译原理" class="header-anchor">#</a> 1.1 编译原理</h3> <p>传统编译语言的编译流程</p> <ul><li>分词/词法分析</li> <li>解析/语法分析</li> <li>代码</li></ul> <p>比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在 语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化 等。</p> <h3 id="_1-2-理解作用域"><a href="#_1-2-理解作用域" class="header-anchor">#</a> 1.2 理解作用域</h3> <p>var a = 2</p> <ol><li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译;否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a。</li> <li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量(查看 1.3 节)。</li></ol> <h4 id="_1-2-3-编译器有话说"><a href="#_1-2-3-编译器有话说" class="header-anchor">#</a> 1.2.3 编译器有话说</h4> <p>LHS 查询: 当变量出现在赋值语句的<strong>左侧</strong>时进行的查询<br>
RHS 查询: 当变量出现在赋值语句的<strong>右侧</strong>时进行的查询(retrieve his source value)</p> <h3 id="_1-3-嵌套作用域"><a href="#_1-3-嵌套作用域" class="header-anchor">#</a> 1.3 嵌套作用域</h3> <p><strong>遍历嵌套作用域链的规则</strong>：引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。</p> <h3 id="_1-4-异常"><a href="#_1-4-异常" class="header-anchor">#</a> 1.4 异常</h3> <p>对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError</p> <p>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p> <div class="custom-block tip"><p class="custom-block-title">注意</p> <p>非严格模式下，RHS查询不到对应的变量时，就会抛出 ReferenceError错误；LHS查询找不到对应变量时，就会在全局作用域中创建一个对应的变量</p></div> <h2 id="_2-词法作用域"><a href="#_2-词法作用域" class="header-anchor">#</a> 2. 词法作用域</h2> <h3 id="_2-1-词法阶段"><a href="#_2-1-词法阶段" class="header-anchor">#</a> 2.1 词法阶段</h3> <p>词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz， 词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接 管对 bar 和 baz 属性的访问。</p> <h3 id="_2-2-欺骗词法"><a href="#_2-2-欺骗词法" class="header-anchor">#</a> 2.2 欺骗词法</h3> <p>欺骗词法作用域会导致性能下降。<br>
在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。</p> <h4 id="_2-2-1-eval"><a href="#_2-2-1-eval" class="header-anchor">#</a> 2.2.1 eval</h4> <p>非严格模式下，eval中的执行的代码作用域就是eval函数所处的作用域
严格模式下，eval执行的内容有着自己独特的作用域</p> <h4 id="_2-2-2-with"><a href="#_2-2-2-with" class="header-anchor">#</a> 2.2.2 with</h4> <p>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象 本身。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span> o1 <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> o1<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

<span class="token function">foo</span><span class="token punctuation">(</span> o2 <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> o2<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2——不好，a 被泄漏到全局作用域上了!</span>
</code></pre></div><p>o1中有a属性，在LHS查询时，在o1作用域中会直接操作<br>
o2中没有a属性，就会向上级作用域查询，直到在全局作用域中没有找到，非严格模式下直接创建了 <code>var a</code> 的全局变量,</p> <h4 id="_2-2-3-性能"><a href="#_2-2-3-性能" class="header-anchor">#</a> 2.2.3 性能</h4> <p><strong>JavaScript 引擎会在编译阶段进行数项的性能优化</strong>。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。<br> <strong><code>eval</code> <code>with</code> 的出现让JavaScript跳过了这种性能优化</strong>，它只能简单地假设关于标识符位置的判断 都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底 是什么。</p> <h2 id="_3-函数作用域和块作用域"><a href="#_3-函数作用域和块作用域" class="header-anchor">#</a> 3. 函数作用域和块作用域</h2> <h3 id="_3-1-函数中的作用域"><a href="#_3-1-函数中的作用域" class="header-anchor">#</a> 3.1 函数中的作用域</h3> <p><strong>函数作用域</strong>的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复 用(事实上在嵌套的作用域中也可以使用)</p> <h3 id="_3-2-隐藏内部实现"><a href="#_3-2-隐藏内部实现" class="header-anchor">#</a> 3.2 隐藏内部实现</h3> <p>有很多原因促成了这种基于作用域的隐藏方法。它们大都是从最小特权原则中引申出来 的，也叫最小授权或最小暴露原则。<br>
这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</p> <h4 id="规避冲突"><a href="#规避冲突" class="header-anchor">#</a> 规避冲突</h4> <p>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致 变量的值被意外覆盖。</p> <h5 id="全局命名空间"><a href="#全局命名空间" class="header-anchor">#</a> 全局命名空间</h5> <p>变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它 们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。</p> <h5 id="模块管理"><a href="#模块管理" class="header-anchor">#</a> 模块管理</h5> <p>另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。</p> <h3 id="_3-3-函数作用域"><a href="#_3-3-函数作用域" class="header-anchor">#</a> 3.3 函数作用域</h3> <p>直接声明函数会造成全局污染，但是函数表达式 <code>(function foo() {...})</code> 可以解决这个问题</p> <h4 id="_3-3-1-匿名和具名"><a href="#_3-3-1-匿名和具名" class="header-anchor">#</a> 3.3.1 匿名和具名</h4> <p><strong>匿名函数表达式</strong> 函数表达式可以是匿名的，而函数声明则不可以省略函数名</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;I waited 1 second!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>匿名函数的问题</p> <ul><li>匿名函数在栈追踪中不会显示有意义的函数名，使得调试很困难</li> <li>如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li> <li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li></ul> <p>给函数表达式指定一个函数名可以解决以上的问题</p> <h4 id="_3-3-2-立即执行表达式"><a href="#_3-3-2-立即执行表达式" class="header-anchor">#</a> 3.3.2 立即执行表达式</h4> <p>立即执行表达式(<strong>IIFE</strong>)的两种方式：<code>(function foo(){..})()</code> <code>(function foo(){..}())</code>，功能上都是一样的</p> <p>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。这种模式在 UMD(Universal Module Definition)项目中被广 泛使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token constant">IIFE</span><span class="token punctuation">(</span> <span class="token parameter">def</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token function">def</span><span class="token punctuation">(</span> window <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">def</span><span class="token punctuation">(</span> <span class="token parameter">global</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3 </span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> global<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_3-4-块作用域"><a href="#_3-4-块作用域" class="header-anchor">#</a> 3.4 块作用域</h3> <h4 id="_3-4-1-with"><a href="#_3-4-1-with" class="header-anchor">#</a> 3.4.1 with</h4> <p>我们在第 2 章讨论过 with 关键字。它不仅是一个难于理解的结构，同时也是块作用域的一个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。</p> <h4 id="_3-4-2-try-catch"><a href="#_3-4-2-try-catch" class="header-anchor">#</a> 3.4.2 try/catch</h4> <p>ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">undefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行一个非法操作来强制制造一个异常</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 能够正常执行! </span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError: err not defined</span>
</code></pre></div><p>尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境(除了老 版本的 IE 浏览器)所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。</p> <h4 id="_3-4-3-let"><a href="#_3-4-3-let" class="header-anchor">#</a> 3.4.3 let</h4> <p>let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。换句话说，let为其声明的变量隐式在了所在的块作用域。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> bar <span class="token operator">=</span> foo <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    bar <span class="token operator">=</span> <span class="token function">something</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError</span>
</code></pre></div><p>使用 var 定义 bar 的话，变量的作用域是外部作用域</p> <p><strong>垃圾回收</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在这里做点有趣的事情</span>
<span class="token punctuation">}</span>
<span class="token comment">// 在这个块中定义的内容可以销毁了! </span>
<span class="token comment">// { 使用let 声明形成的块作用域</span>
    <span class="token keyword">let</span> someReallyBigData <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> 
    <span class="token function">process</span><span class="token punctuation">(</span> someReallyBigData <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// }</span>
<span class="token keyword">var</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span> <span class="token string">&quot;my_button&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span> <span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">click</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;button clicked&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">/*capturingPhase=*/</span><span class="token boolean">false</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执 行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。<br>
但是，由于 click 函数形成 了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构(取决于具体 实现)。<br>
使用let 声明则会形成块作用域，无论click中具体怎么实现，someReallyBigData不会被闭包影响，都可以被回收</p> <p><strong>let 循环</strong></p> <p>以下两段代码是相等的 for 循环头部 <code>let</code> 声明的变量 <code>j</code> 作用域是块级作用域，如果使用 <code>var</code> 声明的话，它的作用域便是外层作用域</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 每个迭代重新绑定!</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">{</span>
    <span class="token keyword">let</span> j<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> i <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 每个迭代重新绑定!</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_3-4-4-const"><a href="#_3-4-4-const" class="header-anchor">#</a> 3.4.4 const</h4> <p>除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的 (常量)。之后任何试图修改值的操作都会引起错误。</p> <h2 id="_4-提升"><a href="#_4-提升" class="header-anchor">#</a> 4. 提升</h2> <h3 id="_4-1-先有鸡还是现有蛋"><a href="#_4-1-先有鸡还是现有蛋" class="header-anchor">#</a> 4.1 先有鸡还是现有蛋</h3> <div class="language-js extra-class"><pre class="language-js"><code>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a<span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// undefined</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_4-2-编译器再度来袭"><a href="#_4-2-编译器再度来袭" class="header-anchor">#</a> 4.2 编译器再度来袭</h3> <p>引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。</p> <p>所以： <strong>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</strong></p> <p>上面第二段代码的实际执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>函数声明会提升，但是函数表达式不会</strong></p> <p>即使是具名的函数表达式，名称标识符也无法在所在作用域中使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不是 ReferenceError, 而是 foo is not a function(TypeError)</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// ReferenceError</span>
<span class="token keyword">var</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// ReferenceError</span>
</code></pre></div><h3 id="_4-3-函数优先"><a href="#_4-3-函数优先" class="header-anchor">#</a> 4.3 函数优先</h3> <p>函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个“重复”声明的代码中)是函数会首先被提升，然后才是变量。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> foo<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token comment">// </span>

<span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div><p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代 码暗示的那样可以被条件判断所控制:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;b&quot;   foo执行时，a已声明但未赋值</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是需要注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该 尽可能避免在块内部声明函数。</p> <h2 id="_5-作用域闭包"><a href="#_5-作用域闭包" class="header-anchor">#</a> 5. 作用域闭包</h2> <h3 id="_5-1-启示"><a href="#_5-1-启示" class="header-anchor">#</a> 5.1 启示</h3> <p>闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿 来识别、拥抱和影响闭包的思维环境。</p> <h3 id="_5-2-实质问题"><a href="#_5-2-实质问题" class="header-anchor">#</a> 5.2 实质问题</h3> <h3 id="_5-3-现在我懂了"><a href="#_5-3-现在我懂了" class="header-anchor">#</a> 5.3 现在我懂了</h3> <h3 id="_5-4-循环和闭包"><a href="#_5-4-循环和闭包" class="header-anchor">#</a> 5.4 循环和闭包</h3> <p>for循环是最常见的闭包</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//  6  6  6  6  6</span>
</code></pre></div><p>上面的代码结果和我们预想中有差异，我们可以通过IIFE声明一个立即执行函数表达式来创建作用域<br>
并在这个立即执行函数表达式中创建一个变量 <code>j</code> 去存储 <code>i</code> 值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> j <span class="token operator">=</span> i
        <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> j <span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> j<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 优雅一点</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> j <span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> j<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>按照创建作用域的思路，我们还可以根据 <code>let</code> 创建块作用域的特性，解决for循环中闭包产生的问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 是的，闭包的块作用域! </span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> j <span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span> j<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 修改后</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> i <span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>for</code> 循环头部的 <code>let</code> 声明还会有一 个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明</p> <h3 id="_5-5-模块"><a href="#_5-5-模块" class="header-anchor">#</a> 5.5 模块</h3> <h4 id="_5-5-1-现代的模块机制"><a href="#_5-5-1-现代的模块机制" class="header-anchor">#</a> 5.5.1 现代的模块机制</h4> <h4 id="_5-5-2-未来的模块机制"><a href="#_5-5-2-未来的模块机制" class="header-anchor">#</a> 5.5.2 未来的模块机制</h4> <h1 id="第二部分"><a href="#第二部分" class="header-anchor">#</a> 第二部分</h1> <h2 id="_1-关于this"><a href="#_1-关于this" class="header-anchor">#</a> 1. 关于this</h2> <h3 id="_1-1-为什么要用this"><a href="#_1-1-为什么要用this" class="header-anchor">#</a> 1.1 为什么要用this</h3> <p>this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。</p> <h3 id="_1-2-误解"><a href="#_1-2-误解" class="header-anchor">#</a> 1.2 误解</h3> <h4 id="_1-2-1-指向自身"><a href="#_1-2-1-指向自身" class="header-anchor">#</a> 1.2.1 指向自身</h4> <p>第一种误解：人们很容易把 this 理解成指向函数自身，这个推断从英语的语法角度来说是说得通的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span>
<span class="token punctuation">}</span>
foo<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 0</span>
<span class="token comment">// foo()调用时，内部的this指向全局环境window，生成一个全局变量count,计算结果为NaN</span>
<span class="token comment">// 使用bind/call函数可以改变foo 中 this指向</span>
</code></pre></div><h4 id="_1-2-2-它的作用域"><a href="#_1-2-2-它的作用域" class="header-anchor">#</a> 1.2.2 它的作用域</h4> <p>第二种误解：this指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。</p> <h3 id="_1-3-this到底是什么"><a href="#_1-3-this到底是什么" class="header-anchor">#</a> 1.3 this到底是什么</h3> <p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调 用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式</p> <h2 id="_2-this全面解析"><a href="#_2-this全面解析" class="header-anchor">#</a> 2. this全面解析</h2> <h3 id="_2-1-调用位置"><a href="#_2-1-调用位置" class="header-anchor">#</a> 2.1 调用位置</h3> <p>在理解 this 的绑定过程之前，首先要理解 <strong>调用位置</strong> :调用位置就是函数在代码中被调用的位置(而不是声明的位置)</p> <h3 id="_2-2-绑定规则"><a href="#_2-2-绑定规则" class="header-anchor">#</a> 2.2 绑定规则</h3> <h4 id="_2-2-1-默认绑定"><a href="#_2-2-1-默认绑定" class="header-anchor">#</a> 2.2.1 默认绑定</h4> <p>函数调用类型:独立函数调用，可以把这条规则看作是无法应用其他规则时的默认规则。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div><p>在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用 <code>默认绑定</code>，无法应用其他规则。</p> <p>但在严格模式下,全局对象无法使用默认绑定，this被绑定到undefined</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Uncaught TypeError: Cannot read property 'a' of undefined</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">注意</p> <p>通常来说你不应该在代码中混合使用 strict mode 和 non-strict mode,整个程序要么严格，要么非严格。 但第三方库中，其严格程度和你的代码有所不同，因此一定要注意这类兼容性细节。</p></div> <h4 id="_2-2-2-隐式绑定"><a href="#_2-2-2-隐式绑定" class="header-anchor">#</a> 2.2.2 隐式绑定</h4> <p>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</p> <p>对象属性引用链中只有最顶层或者说最后一层会影响调用位置</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">,</span>foo<span class="token operator">:</span> foo <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>obj2<span class="token operator">:</span> obj2 <span class="token punctuation">}</span><span class="token punctuation">;</span>
obj1<span class="token punctuation">.</span>obj2<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 42</span>
</code></pre></div><p><strong>隐式丢失</strong></p> <p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时。<strong>这里有一个隐式赋值的过程</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">doFoo</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 隐式赋值 fn = obj.foo,fn();</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- 调用位置!</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> foo<span class="token operator">:</span> foo <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// a 是全局对象的属性 </span>
<span class="token function">doFoo</span><span class="token punctuation">(</span> obj<span class="token punctuation">.</span>foo <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;，</span>
</code></pre></div><h4 id="_2-2-3-显示绑定"><a href="#_2-2-3-显示绑定" class="header-anchor">#</a> 2.2.3 显示绑定</h4> <h5 id="硬绑定"><a href="#硬绑定" class="header-anchor">#</a> 硬绑定</h5> <p>硬绑定的一个典型场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">something</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> something<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> something<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>arguments<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">// 2,3</span>
</code></pre></div><p>Function.prototype.bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p> <h5 id="api调用中的-上下文"><a href="#api调用中的-上下文" class="header-anchor">#</a> API调用中的“上下文”</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> el<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">&quot;awesome&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 调用 foo(..) 时把 this 绑定到 obj </span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> foo<span class="token punctuation">,</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1 awesome 2 awesome 3 awesome</span>
</code></pre></div><h4 id="_2-2-4-new绑定"><a href="#_2-2-4-new绑定" class="header-anchor">#</a> 2.2.4 new绑定</h4> <p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p> <ol><li>创建(或者说构造)一个全新的对象。</li> <li>这个新对象会被执行[[原型]]连接。</li> <li>这个新对象会绑定到函数调用的this。</li> <li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><h5 id="判断this"><a href="#判断this" class="header-anchor">#</a> 判断this</h5> <ol><li>函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。var bar = new foo()</li> <li>函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。var bar = foo.call(obj2)</li> <li>函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。var bar = obj1.foo()</li> <li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。var bar = foo()</li></ol> <h3 id="_2-4-绑定例外"><a href="#_2-4-绑定例外" class="header-anchor">#</a> 2.4 绑定例外</h3> <h4 id="_2-4-1-被忽略的this"><a href="#_2-4-1-被忽略的this" class="header-anchor">#</a> 2.4.1 被忽略的this</h4> <p>如果把undefined 或 null 作为this的绑定对象传入 call 、 apply 或者 bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this(比如第三方库中的一个函数)，那默认绑定规则会把 this 绑定到全局对象(在浏览 器中这个对象是 window)，这将导致不可预计的后果(比如修改全局对象)。</p> <h5 id="更安全的this"><a href="#更安全的this" class="header-anchor">#</a> 更安全的this</h5> <p>一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序产生任何副作用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&quot;a:&quot;</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">&quot;, b:&quot;</span> <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment">// 我们的 DMZ 空对象</span>
<span class="token keyword">var</span> ø <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 把数组展开成参数</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> ø<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a:2, b:3</span>
<span class="token comment">// 使用 bind(..) 进行柯里化 </span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span> ø<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a:2, b:3</span>
</code></pre></div><h4 id="_2-4-2-间接引用"><a href="#_2-4-2-间接引用" class="header-anchor">#</a> 2.4.2 间接引用</h4> <p>间接引用最容易在赋值时发生</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> foo<span class="token operator">:</span> foo <span class="token punctuation">}</span><span class="token punctuation">;</span> 
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
o<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">(</span>p<span class="token punctuation">.</span>foo <span class="token operator">=</span> o<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。</p> <h4 id="_2-4-3-软绑定"><a href="#_2-4-3-软绑定" class="header-anchor">#</a> 2.4.3 软绑定</h4> <p>硬绑定会大大降低函数的灵活性，使 用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>softBind<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">softBind</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token comment">// 捕获所有 curried 参数</span>
        <span class="token keyword">var</span> curried <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">var</span> <span class="token function-variable function">bound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span> <span class="token operator">||</span> <span class="token keyword">this</span> <span class="token operator">===</span> <span class="token punctuation">(</span>window <span class="token operator">||</span> global<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span> obj <span class="token operator">:</span> <span class="token keyword">this</span> curried<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> curried<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        bound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> fn<span class="token punctuation">.</span>prototype <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> bound<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this</p> <h3 id="_2-5-this词法"><a href="#_2-5-this词法" class="header-anchor">#</a> 2.5 this词法</h3> <p>箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决 定 this。</p> <h2 id="_3-对象"><a href="#_3-对象" class="header-anchor">#</a> 3. 对象</h2> <p>####3.1 语法
对象可以通过两种形式定义：声明形式和构造形式</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 声明形式</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> key<span class="token operator">:</span> value <span class="token punctuation">}</span>

<span class="token comment">// 构造形式</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>key <span class="token operator">=</span> value<span class="token punctuation">;</span>
</code></pre></div><h3 id="_3-2-类型"><a href="#_3-2-类型" class="header-anchor">#</a> 3.2 类型</h3> <p>Javascript六种主要类型（ES5）</p> <ul><li>string</li> <li>number</li> <li>boolean</li> <li>null</li> <li>undefined</li> <li>object</li></ul> <p>null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行typeof null 会返回字符串 'object'</p> <h4 id="内置对象"><a href="#内置对象" class="header-anchor">#</a> 内置对象</h4> <ul><li>String</li> <li>Number</li> <li>Boolean</li> <li>Object</li> <li>Function</li> <li>Array</li> <li>Date</li> <li>RegExp</li> <li>Error</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> strPrimitive <span class="token operator">=</span> <span class="token string">&quot;I am a string&quot;</span><span class="token punctuation">;</span> 
<span class="token keyword">typeof</span> strPrimitive<span class="token punctuation">;</span> <span class="token comment">// &quot;string&quot; </span>
strPrimitive <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

<span class="token keyword">var</span> strObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span> <span class="token string">&quot;I am a string&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">typeof</span> strObject<span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>
strObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="_3-3-内容"><a href="#_3-3-内容" class="header-anchor">#</a> 3.3 内容</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2 </span>
myObject<span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>.a 语法通 常被称为“属性访问”，[&quot;a&quot;] 语法通常被称为“键访问”。</p> <p>键访问可以接受任意UTF-8/Unicode字符串作为属性名。举例来说，如果要引用名称为&quot;Super-Fun!&quot;的属性，就必须使用['Super-Fun!']访问。</p> <p>在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的 确是数字，但是在对象属性名中数字会被转换成字符串，<strong>所以当心不要搞混对象和数组中数字的用法</strong>:</p> <h4 id="_3-3-1-可计算属性名"><a href="#_3-3-1-可计算属性名" class="header-anchor">#</a> 3.3.1 可计算属性名</h4> <p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:</p> <h4 id="_3-3-2-属性与方法"><a href="#_3-3-2-属性与方法" class="header-anchor">#</a> 3.3.2 属性与方法</h4> <p>“函数”和“方法”在 JavaScript 中是可以互换的。</p> <h4 id="_3-3-3-数组"><a href="#_3-3-3-数组" class="header-anchor">#</a> 3.3.3 数组</h4> <p>数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">&quot;bar&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> 
myArray<span class="token punctuation">.</span>baz <span class="token operator">=</span> <span class="token string">&quot;baz&quot;</span><span class="token punctuation">;</span> 
myArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span>
myArray<span class="token punctuation">.</span>baz<span class="token punctuation">;</span> <span class="token comment">// &quot;baz&quot;</span>
</code></pre></div><p>可以看到虽然添加了命名属性(无论是通过 . 语法还是 [] 语法)，数组的 length 值并未发 生变化。</p> <p><strong>注意</strong>:如果你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成 一个数值下标(因此会修改数组的内容而不是添加一个属性)</p> <h4 id="_3-3-4-复制对象"><a href="#_3-3-4-复制对象" class="header-anchor">#</a> 3.3.4 复制对象</h4> <p>对于JSON安全（也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）的对象来说，有一种巧妙的复制方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> newObj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>ES6定义了Object.assign(..)方法实现浅复制，第一个参数是目标对象，之后还可以跟一个 或多个源对象。它会遍历一个或多个源对象的所有可枚举(enumerable，参见下面的代码) 的自有键(owned key，很快会介绍)并把它们复制(使用 = 操作符赋值)到目标对象，最 后返回目标对象</p> <h4 id="_3-3-5-属性描述符"><a href="#_3-3-5-属性描述符" class="header-anchor">#</a> 3.3.5 属性描述符</h4> <p>从 ES5 开始，所有的属性都具备了属性描述符。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span> myObject<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// {</span>
<span class="token comment">//      value: 2,</span>
<span class="token comment">//      writable: true,</span>
<span class="token comment">//      enumerable: true,</span>
<span class="token comment">//      configurable: true </span>
<span class="token comment">// }</span>
</code></pre></div><p>创建对象时，可以使用Object.defineProperty()添加一个新属性或者修改一个已有属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span> myObject<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> 
    value<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> 
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> 
    enumerable<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><ul><li>Writable
<ul><li>属性值是否可以改变，严格模式下，Writable为false的值修改会报错。</li></ul></li> <li>Configurable
<ul><li>只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符:</li> <li>不管是不是处于严格模式，尝 试修改一个不可配置的属性描述符都会出错。</li> <li>把Configurable修改成false是单向操作</li> <li>configurable:false 时，这个属性禁止被删除</li></ul></li> <li>Enumerable
<ul><li>这个描述符控制的是属性是否会出现在对象的属性枚举中</li></ul></li></ul> <h4 id="_3-3-6-不变性"><a href="#_3-3-6-不变性" class="header-anchor">#</a> 3.3.6 不变性</h4> <h5 id="_1-对象常量"><a href="#_1-对象常量" class="header-anchor">#</a> 1. 对象常量</h5> <p>结合writable:false 和 configuration:false 可以创建一个真正的常量属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span> myObject<span class="token punctuation">,</span> <span class="token string">&quot;FAVORITE_NUMBER&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> 
    value<span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">,</span>
    writable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">false</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="_2-禁止扩展"><a href="#_2-禁止扩展" class="header-anchor">#</a> 2. 禁止扩展</h5> <p>Object.preventExtensions(..)</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span> myObject <span class="token punctuation">)</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> 
myObject<span class="token punctuation">.</span>b<span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre></div><p>在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。</p> <h5 id="_3-密封"><a href="#_3-密封" class="header-anchor">#</a> 3. 密封</h5> <p>Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。</p> <p>所以，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以 修改属性的值)。</p> <h5 id="_4-冻结"><a href="#_4-冻结" class="header-anchor">#</a> 4. 冻结</h5> <p>Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们 的值。</p> <h4 id="_3-3-7-get"><a href="#_3-3-7-get" class="header-anchor">#</a> 3.3.7 [[Get]]</h4> <p>myObject.a 在 myObject 上实际上是实现了 [[Get]] 操作(有点像函数调 用:<a href="">[Get]</a>)。</p> <ul><li>对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。</li> <li>如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要 的行为。我们会在第 5 章中介绍这个行为(其实就是遍历可能存在的 [[Prototype]] 链， 也就是原型链)。</li> <li>无论如何都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined</li></ul> <h4 id="_3-8-put"><a href="#_3-8-put" class="header-anchor">#</a> 3.8 [[Put]]</h4> <p>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性(这 是最重要的因素)。</p> <ul><li>如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。
<ul><li><ol><li>属性是否是访问描述符(参见3.3.9节)?如果是并且存在setter就调用setter。</li></ol></li> <li><ol start="2"><li>属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li></ol></li> <li><ol start="3"><li>如果都不是，将该值设置为属性的值。</li></ol></li></ul></li> <li>如果对象中不存在这个属性，[[Put]] 操作会更加复杂。我们会在第 5 章讨论 [[Prototype]] 时详细进行介绍。</li></ul> <h4 id="_3-9-getter-setter"><a href="#_3-9-getter-setter" class="header-anchor">#</a> 3.9 Getter Setter</h4> <p>当你给一个属性定义 getter、setter 或者两者都有时，这个属性会被定义为“访问描述 符”(和“数据描述符”相对)。对于访问描述符来说，JavaScript 会忽略它们的 value 和 writable 特性，取而代之的是关心 set 和 get(还有 configurable 和 enumerable)特性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 给 a 定义一个 getter </span>
    <span class="token keyword">get</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> 
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>由于我们只定义了 a 的 getter，所以对 a 的值进行设置时 set 操作会忽略赋值操作，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 给 a 定义一个 getter </span>
    <span class="token keyword">get</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_a_<span class="token punctuation">;</span> 
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 给 a 定义一个 setter </span>
    <span class="token keyword">set</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_a_ <span class="token operator">=</span> val <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> 
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 4</span>
</code></pre></div><p>名称 <em>a</em> 只是一种惯例，没有任何特殊的行为</p> <h4 id="_3-3-10-存在性"><a href="#_3-3-10-存在性" class="header-anchor">#</a> 3.3.10 存在性</h4> <p>如 myObject.a 的属性访问返回值可能是 undefined，但是这个值有可能 是属性中存储的 undefined，也可能是因为属性不存在所以返回 undefined</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span> <span class="token keyword">in</span> myObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
<span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span> <span class="token keyword">in</span> myObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span> <span class="token string">&quot;b&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre></div><p>in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中(参见第 5 章)。相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。</p> <h5 id="枚举"><a href="#枚举" class="header-anchor">#</a> 枚举</h5> <p>enumerable为true时，属性值遍历，会出现在循环中；为false时，不会出现在循环中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span> myObject<span class="token punctuation">,</span> <span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span>
    <span class="token comment">// 让 a 像普通属性一样可以枚举 </span>
     enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span> myObject<span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span>
    <span class="token comment">// 让b不可枚举</span>
    <span class="token punctuation">{</span> enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>b<span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span> <span class="token keyword">in</span> myObject<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span> <span class="token string">&quot;b&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token comment">// .......</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> k <span class="token keyword">in</span> myObject<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> k<span class="token punctuation">,</span> myObject<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// &quot;a&quot; 2</span>
</code></pre></div><p>Object.keys(..) 会返回一个数组，包含所有可枚举属性，Object.getOwnPropertyNames(..) 会返回一个数组，包含所有属性，无论它们是否可枚举。</p> <p>in 和 hasOwnProperty(..) 的区别在于是否查找 [[Prototype]] 链，然而，Object.keys(..) 和 Object.getOwnPropertyNames(..) 都只会查找对象直接包含的属性。</p> <h3 id="_3-4-遍历"><a href="#_3-4-遍历" class="header-anchor">#</a> 3.4 遍历</h3> <p>forEach(..) 会遍历数组中的所有值并忽略回调函数的返回值。every(..) 会一直运行直到回调函数返回 false(或者“假”值)，some(..) 会一直运行直到回调函数返回 true(或者 “真”值)。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>遍历数组下标时采用的是数字顺序(for 循环或者其他迭代器)，但是遍历对 象属性时的顺序是不确定的，在不同的 JavaScript 引擎中可能不一样。因此， 在不同的环境中需要保证一致性时，一定不要相信任何观察到的顺序，它们 是不可靠的。</p></div> <h4 id="for-in"><a href="#for-in" class="header-anchor">#</a> for...in</h4> <p>使用 for..in 遍历对象是无法直接获取属性值的，因为它实际上遍历的是对象中的所有可 枚举属性，你需要手动获取属性值。</p> <h4 id="for-of"><a href="#for-of" class="header-anchor">#</a> for...of</h4> <p>遍历属性值</p> <p>for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值。</p> <p>数组有内置的@@iterator，我们可以直接使用<code>for...of</code>，手动使用它大致如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> myArray<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value:1, done:false } </span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value:2, done:false } </span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value:3, done:false } </span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { done:true }</span>
</code></pre></div><p>对象没有内置的@@iterator,当然我们可以自定义</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span> myObject<span class="token punctuation">,</span> Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">,</span> <span class="token punctuation">{</span> 
    enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    writable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> ks <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span> o <span class="token punctuation">)</span><span class="token punctuation">;</span> 
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                <span class="token keyword">return</span> <span class="token punctuation">{</span>
                    value<span class="token operator">:</span> o<span class="token punctuation">[</span>ks<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                    done<span class="token operator">:</span> <span class="token punctuation">(</span>idx <span class="token operator">&gt;</span> ks<span class="token punctuation">.</span>length<span class="token punctuation">)</span> 
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 手动遍历 myObject</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> myObject<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value:2, done:false } </span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value:3, done:false } </span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { value:undefined, done:true }</span>
<span class="token comment">// 用 for..of 遍历 myObject </span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> v <span class="token keyword">of</span> myObject<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 2 // 3</span>
</code></pre></div><h2 id="_4-混合对象-类"><a href="#_4-混合对象-类" class="header-anchor">#</a> 4. 混合对象“类”</h2> <h2 id="_5-原型"><a href="#_5-原型" class="header-anchor">#</a> 5. 原型</h2> <h3 id="_5-1-prototype"><a href="#_5-1-prototype" class="header-anchor">#</a> 5.1 [[prototype]]</h3> <p>Object.create会创建一个对象并把这个对象的[[prototype]]关联到指定的对象。</p> <h4 id="_5-1-1-object-prototype"><a href="#_5-1-1-object-prototype" class="header-anchor">#</a> 5.1.1 Object.prototype</h4> <p>[[prototype]]的尽头是 Object.prototype</p> <h4 id="_5-1-2-属性设置和屏蔽"><a href="#_5-1-2-属性设置和屏蔽" class="header-anchor">#</a> 5.1.2 属性设置和屏蔽</h4> <p>设置 <code>myObject.foo = 'bar';</code> 时，foo不存在myObject中而存在其原型链上时出现的三种情况</p> <ol><li>如果[[prototype]]链上层存在名为foo的普通数据访问属性并且没有被标记为只读（writable: true），那就会直接在myObject中添加一个新属性，它是<strong>屏蔽属性</strong>。</li> <li>如果[[prototype]]链上层存在foo，但它被标记为只读(writable: false)，那么无法修改已有属性或者在myObject上创建屏蔽属性。严格模式下会报错，否则会被忽略。</li> <li>如果[[protorype]]链上层存在foo并且它是一个setter，那它一定会调用这个setter。foo不会被添加到myObject上，也不会重新定义折合setter。</li></ol> <p>如果希望在第二第三种情况下也能屏蔽foo，那就不能使用 = 操作符赋值，而是使用 Object.defineProperty()</p> <p><strong>隐式屏蔽</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> anotherObject <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span><span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> myObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> anotherObject <span class="token punctuation">)</span><span class="token punctuation">;</span>

anotherObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2 </span>
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2</span>

anotherObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span>
myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

myObject<span class="token punctuation">.</span>a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 隐式屏蔽! </span>
anotherObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2</span>
myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 3</span>
myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span> <span class="token string">&quot;a&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h3 id="_5-2-类"><a href="#_5-2-类" class="header-anchor">#</a> 5.2 类</h3> <h4 id="_5-2-1-类函数"><a href="#_5-2-1-类函数" class="header-anchor">#</a> 5.2.1 类函数</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><h4 id="_5-2-2-构造函数"><a href="#_5-2-2-构造函数" class="header-anchor">#</a> 5.2.2 构造函数</h4> <p>函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</p> <h4 id="_5-2-3-技术"><a href="#_5-2-3-技术" class="header-anchor">#</a> 5.2.3 技术</h4> <h3 id="_5-3-（原型）继承"><a href="#_5-3-（原型）继承" class="header-anchor">#</a> 5.3 （原型）继承</h3> <p>instanceof 操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof 回答的问题是:在 a 的整条 [[Prototype]] 链中是否有指向 Foo.prototype 的对象?</p> <h3 id="_5-4-对象关联"><a href="#_5-4-对象关联" class="header-anchor">#</a> 5.4 对象关联</h3> <p>Object.create(null) 会 创 建 一 个 拥 有 空( 或 者 说 null)[[Prototype]] 链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符(之前解释过)无法进行判断，因此总是会返回 false。 这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原 型链的干扰，因此非常适合用来存储数据。</p> <p>// todo <br>
内容不好梳理，回头看书再梳理。</p> <h2 id="_6-行为委托"><a href="#_6-行为委托" class="header-anchor">#</a> 6. 行为委托</h2> <h3 id="_6-1-面向委托的设计"><a href="#_6-1-面向委托的设计" class="header-anchor">#</a> 6.1 面向委托的设计</h3> <h4 id="_6-1-1-类理论"><a href="#_6-1-1-类理论" class="header-anchor">#</a> 6.1.1 类理论</h4> <p>类设计模式鼓励你在继承时使用方法重写（和多态）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>
    id<span class="token punctuation">;</span>
    <span class="token function">Task</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">ID</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> id <span class="token operator">=</span> <span class="token constant">ID</span> <span class="token punctuation">}</span>
    <span class="token function">outputTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">output</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">XYZ</span> inherits Task <span class="token punctuation">{</span>
    label<span class="token punctuation">;</span>
    <span class="token constant">XYZ</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">ID</span><span class="token punctuation">,</span>Label</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token constant">ID</span><span class="token punctuation">)</span><span class="token punctuation">;</span> label <span class="token operator">=</span> label <span class="token punctuation">}</span>
    <span class="token function">outputTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">output</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_6-1-2-委托理论"><a href="#_6-1-2-委托理论" class="header-anchor">#</a> 6.1.2 委托理论</h4> <div class="language-js extra-class"><pre class="language-js"><code>Task <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">setID</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">ID</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token constant">ID</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">outputID</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 让XYZ委托Task</span>
<span class="token constant">XYZ</span> <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Task<span class="token punctuation">)</span>
<span class="token constant">XYZ</span><span class="token punctuation">.</span><span class="token function-variable function">prepareTask</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">ID</span><span class="token punctuation">,</span>Label</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setID</span><span class="token punctuation">(</span><span class="token constant">ID</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>label <span class="token operator">=</span> Label
<span class="token punctuation">}</span>
<span class="token constant">XYZ</span><span class="token punctuation">.</span><span class="token function-variable function">outputTaskDetails</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">outputID</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>label<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>对象关联风格的代码还有一些不同之处
<ol><li>上面的代码中，id 和 label 数据成员都是直接存储在 XYZ 上（而不是Task），在[[prototype]]中最好把状态保存在委托者（XYZ）而不是委托目标身上。</li> <li>类设计模式中，它的优势是重写（多态）。委托行为中，我们尽量避免在[[prototype]]链的不同级别中使用相同的命名。</li> <li>委托行为意味着某些对象(XYZ)在找不到属性或者方法引用时会把这个请求委托给另一个对象(Task)</li></ol></li></ul> <h5 id="_1-互相委托（禁止）"><a href="#_1-互相委托（禁止）" class="header-anchor">#</a> 1. 互相委托（禁止）</h5> <p>你无法在两个或两个以上互相(双向)委托的对象之间创建循环委托。如果你把 B 关联到 A 然后试着把 A 关联到 B，就会出错。</p> <h5 id="_2-调试"><a href="#_2-调试" class="header-anchor">#</a> 2. 调试</h5> <h4 id="_6-1-3-比较思维模型"><a href="#_6-1-3-比较思维模型" class="header-anchor">#</a> 6.1.3 比较思维模型</h4> <h3 id="_6-2-类与对象"><a href="#_6-2-类与对象" class="header-anchor">#</a> 6.2 类与对象</h3> <h4 id="_6-2-1-空间-类"><a href="#_6-2-1-空间-类" class="header-anchor">#</a> 6.2.1 空间“类”</h4> <h4 id="_6-2-2-委托控件对象"><a href="#_6-2-2-委托控件对象" class="header-anchor">#</a> 6.2.2 委托控件对象</h4> <p>对象关联可以更好地支持关注分离(separation of concerns)原则，创建和初始化并不需要 合并为一个步骤。</p> <h3 id="_6-3-更简洁的设计"><a href="#_6-3-更简洁的设计" class="header-anchor">#</a> 6.3 更简洁的设计</h3></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/book/code/you_dont_know_javascript_2.html">
        你不知道的JavaScript(中)
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.52282d9c.js" defer></script><script src="/assets/js/2.b2576fa9.js" defer></script><script src="/assets/js/21.875ef651.js" defer></script>
  </body>
</html>
